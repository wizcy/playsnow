<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Sand Tetris - Play Free Online | PlayNow</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a1008;
  color: #e8d5a3;
  font-family: 'Segoe UI', sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  padding: 10px;
  overflow-x: hidden;
}
h1 {
  font-size: 1.4rem;
  color: #f0c060;
  margin-bottom: 8px;
  text-shadow: 0 0 10px rgba(240,192,96,0.5);
  letter-spacing: 2px;
}
#game-wrapper {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}
#game-canvas {
  border: 2px solid #5a3a10;
  box-shadow: 0 0 20px rgba(200,140,40,0.3);
  display: block;
  image-rendering: pixelated;
}
#side-panel {
  width: 110px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.panel-box {
  background: #2a1a08;
  border: 1px solid #5a3a10;
  border-radius: 6px;
  padding: 8px;
  text-align: center;
}
.panel-box h3 {
  font-size: 0.65rem;
  color: #a07030;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 4px;
}
.panel-box .value {
  font-size: 1.3rem;
  font-weight: bold;
  color: #f0c060;
}
#next-canvas {
  display: block;
  margin: 4px auto 0;
  image-rendering: pixelated;
}
#btn-start {
  width: 100%;
  padding: 8px;
  background: #8b4513;
  color: #f0c060;
  border: 1px solid #c07030;
  border-radius: 6px;
  font-size: 0.85rem;
  font-weight: bold;
  cursor: pointer;
  letter-spacing: 1px;
  transition: background 0.2s;
}
#btn-start:hover { background: #a0521a; }
#mobile-controls {
  display: none;
  gap: 8px;
  margin-top: 10px;
  flex-wrap: wrap;
  justify-content: center;
}
.ctrl-btn {
  width: 56px;
  height: 56px;
  background: #2a1a08;
  border: 1px solid #5a3a10;
  border-radius: 8px;
  color: #f0c060;
  font-size: 1.4rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
  transition: background 0.1s;
}
.ctrl-btn:active { background: #4a2a10; }
#msg-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(10,6,2,0.92);
  border: 2px solid #c07030;
  border-radius: 10px;
  padding: 20px 28px;
  text-align: center;
  pointer-events: none;
  z-index: 10;
}
#msg-overlay h2 { color: #f0c060; font-size: 1.3rem; margin-bottom: 8px; }
#msg-overlay p  { color: #c0a060; font-size: 0.85rem; }
#canvas-container { position: relative; }
@media (max-width: 520px) {
  #mobile-controls { display: flex; }
  h1 { font-size: 1.1rem; }
  #side-panel { width: 90px; }
  .panel-box .value { font-size: 1.1rem; }
}
</style>
</head>
<body>
<h1>â³ SAND TETRIS</h1>
<div id="game-wrapper">
  <div id="canvas-container">
    <canvas id="game-canvas"></canvas>
    <div id="msg-overlay">
      <h2>SAND TETRIS</h2>
      <p>Press Start or Space</p>
    </div>
  </div>
  <div id="side-panel">
    <div class="panel-box">
      <h3>Next</h3>
      <canvas id="next-canvas" width="80" height="80"></canvas>
    </div>
    <div class="panel-box">
      <h3>Score</h3>
      <div class="value" id="score-val">0</div>
    </div>
    <div class="panel-box">
      <h3>Level</h3>
      <div class="value" id="level-val">1</div>
    </div>
    <div class="panel-box">
      <h3>Lines</h3>
      <div class="value" id="lines-val">0</div>
    </div>
    <button id="btn-start">START</button>
  </div>
</div>
<div id="mobile-controls">
  <div class="ctrl-btn" id="btn-left">â—€</div>
  <div class="ctrl-btn" id="btn-rotate">ğŸ”„</div>
  <div class="ctrl-btn" id="btn-right">â–¶</div>
  <div class="ctrl-btn" id="btn-down">â–¼</div>
</div>
<script>
// â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const COLS = 10, ROWS = 20;
const SAND_SIZE = 4; // px per sand particle
const SAND_COLS = COLS * SAND_SIZE;  // 40
const SAND_ROWS = ROWS * SAND_SIZE;  // 80
const DENSITY_THRESHOLD = 0.90;

// Tetromino shapes (each cell = 1 block = SAND_SIZEÃ—SAND_SIZE sand grid cells)
const SHAPES = {
  I: { cells: [[0,1],[1,1],[2,1],[3,1]], color: [80,220,220] },
  O: { cells: [[0,0],[1,0],[0,1],[1,1]], color: [240,200,60] },
  T: { cells: [[1,0],[0,1],[1,1],[2,1]], color: [180,80,220] },
  S: { cells: [[1,0],[2,0],[0,1],[1,1]], color: [80,200,80] },
  Z: { cells: [[0,0],[1,0],[1,1],[2,1]], color: [220,60,60] },
  J: { cells: [[0,0],[0,1],[1,1],[2,1]], color: [80,100,220] },
  L: { cells: [[2,0],[0,1],[1,1],[2,1]], color: [240,140,40] },
};
const SHAPE_KEYS = Object.keys(SHAPES);

// â”€â”€â”€ Canvas setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('next-canvas');
const nextCtx = nextCanvas.getContext('2d');

function resize() {
  const maxH = window.innerHeight - 160;
  const maxW = window.innerWidth - 140;
  const cellPx = Math.max(4, Math.min(Math.floor(maxH / ROWS), Math.floor(maxW / COLS)));
  const sandPx = Math.max(1, Math.floor(cellPx / SAND_SIZE));
  canvas._sandPx = sandPx;
  canvas.width  = SAND_COLS * sandPx;
  canvas.height = SAND_ROWS * sandPx;
}
resize();
window.addEventListener('resize', () => { resize(); if (game) game.draw(); });

// â”€â”€â”€ Sand Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// grid[r][c] = null | [r,g,b]
class SandGrid {
  constructor() {
    this.cells = new Array(SAND_ROWS).fill(null).map(() => new Array(SAND_COLS).fill(null));
  }
  get(r, c) {
    if (r < 0 || r >= SAND_ROWS || c < 0 || c >= SAND_COLS) return true; // treat OOB as solid
    return this.cells[r][c];
  }
  set(r, c, color) { if (r >= 0 && r < SAND_ROWS && c >= 0 && c < SAND_COLS) this.cells[r][c] = color; }
  isEmpty(r, c) { return this.get(r, c) === null; }

  // Simulate one physics step â€” process bottom-up for stability
  step() {
    // Shuffle columns each row to avoid directional bias
    const colOrder = Array.from({length: SAND_COLS}, (_, i) => i);
    for (let r = SAND_ROWS - 2; r >= 0; r--) {
      // shuffle col order for this row
      for (let i = colOrder.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [colOrder[i], colOrder[j]] = [colOrder[j], colOrder[i]];
      }
      for (const c of colOrder) {
        const color = this.cells[r][c];
        if (!color) continue;
        // 1. straight down
        if (this.isEmpty(r + 1, c)) {
          this.cells[r + 1][c] = color;
          this.cells[r][c] = null;
          continue;
        }
        // 2. diagonal â€” pick left/right randomly
        const goLeft = Math.random() < 0.5;
        const d1 = goLeft ? -1 : 1;
        const d2 = goLeft ?  1 : -1;
        if (this.isEmpty(r + 1, c + d1)) {
          this.cells[r + 1][c + d1] = color;
          this.cells[r][c] = null;
        } else if (this.isEmpty(r + 1, c + d2)) {
          this.cells[r + 1][c + d2] = color;
          this.cells[r][c] = null;
        }
        // else: stay put
      }
    }
  }

  // Check rows for â‰¥90% density, return list of cleared rows
  checkLines() {
    const cleared = [];
    for (let r = 0; r < SAND_ROWS; r++) {
      let count = 0;
      for (let c = 0; c < SAND_COLS; c++) if (this.cells[r][c]) count++;
      if (count / SAND_COLS >= DENSITY_THRESHOLD) cleared.push(r);
    }
    return cleared;
  }

  clearRows(rows) {
    const rowSet = new Set(rows);
    for (const r of rowSet) {
      for (let c = 0; c < SAND_COLS; c++) this.cells[r][c] = null;
    }
    // Let sand above fall â€” run extra physics steps
    for (let i = 0; i < 30; i++) this.step();
  }

  // Check if any sand has reached the top 4 rows (game over zone)
  isOverflowed() {
    for (let r = 0; r < SAND_SIZE; r++)
      for (let c = 0; c < SAND_COLS; c++)
        if (this.cells[r][c]) return true;
    return false;
  }
}

// â”€â”€â”€ Tetromino â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Piece {
  constructor(key) {
    this.key = key;
    const s = SHAPES[key];
    this.color = s.color;
    // cells in block coords (each block = SAND_SIZE sand cells)
    this.blocks = s.cells.map(([x, y]) => [x, y]);
    // spawn at top center
    const minX = Math.min(...this.blocks.map(b => b[0]));
    const maxX = Math.max(...this.blocks.map(b => b[0]));
    const w = maxX - minX + 1;
    this.bx = Math.floor((COLS - w) / 2) - minX; // block x offset
    this.by = 0; // block y offset
  }

  rotate() {
    // Rotate 90Â° clockwise around centroid
    const cx = (Math.max(...this.blocks.map(b => b[0])) + Math.min(...this.blocks.map(b => b[0]))) / 2;
    const cy = (Math.max(...this.blocks.map(b => b[1])) + Math.min(...this.blocks.map(b => b[1]))) / 2;
    return this.blocks.map(([x, y]) => [
      Math.round(cy - y + cx),
      Math.round(x - cx + cy)
    ]);
  }

  // Sand-grid coords of all sand cells this piece occupies
  sandCells() {
    const result = [];
    for (const [bx, by] of this.blocks) {
      const sx = (this.bx + bx) * SAND_SIZE;
      const sy = (this.by + by) * SAND_SIZE;
      for (let dy = 0; dy < SAND_SIZE; dy++)
        for (let dx = 0; dx < SAND_SIZE; dx++)
          result.push([sy + dy, sx + dx]);
    }
    return result;
  }

  // Check collision against sand grid
  collides(grid, dbx = 0, dby = 0, newBlocks = null) {
    const blocks = newBlocks || this.blocks;
    for (const [bx, by] of blocks) {
      const sx = (this.bx + bx + dbx) * SAND_SIZE;
      const sy = (this.by + by + dby) * SAND_SIZE;
      for (let dy = 0; dy < SAND_SIZE; dy++) {
        for (let dx = 0; dx < SAND_SIZE; dx++) {
          const r = sy + dy, c = sx + dx;
          if (r >= SAND_ROWS) return true;
          if (c < 0 || c >= SAND_COLS) return true;
          if (grid.get(r, c) !== null && grid.get(r, c) !== undefined && grid.get(r, c) !== true) return true;
        }
      }
    }
    return false;
  }
}

// â”€â”€â”€ Game â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Game {
  constructor() {
    this.grid = new SandGrid();
    this.current = null;
    this.next = null;
    this.score = 0;
    this.level = 1;
    this.lines = 0;
    this.running = false;
    this.over = false;
    this.dropTimer = 0;
    this.dropInterval = 800; // ms
    this.physicsTimer = 0;
    this.physicsInterval = 16; // ~60fps physics
    this.lastTime = 0;
    this.sandFalling = false; // true while post-clear sand settles
    this.settleFrames = 0;
    this.pendingClear = false;
  }

  start() {
    this.grid = new SandGrid();
    this.score = 0; this.level = 1; this.lines = 0;
    this.over = false; this.running = true;
    this.dropInterval = 800;
    this.next = new Piece(SHAPE_KEYS[Math.floor(Math.random() * SHAPE_KEYS.length)]);
    this.spawnPiece();
    this.updateUI();
    hideMsgOverlay();
    requestAnimationFrame(t => this.loop(t));
  }

  spawnPiece() {
    this.current = this.next;
    this.next = new Piece(SHAPE_KEYS[Math.floor(Math.random() * SHAPE_KEYS.length)]);
    this.drawNext();
    if (this.current.collides(this.grid)) {
      this.gameOver();
    }
  }

  loop(ts) {
    if (!this.running) return;
    const dt = Math.min(ts - this.lastTime, 50);
    this.lastTime = ts;

    // Physics step
    this.physicsTimer += dt;
    if (this.physicsTimer >= this.physicsInterval) {
      this.physicsTimer = 0;
      this.grid.step();

      if (this.sandFalling) {
        this.settleFrames++;
        if (this.settleFrames > 45) {
          this.sandFalling = false;
          this.settleFrames = 0;
          // Check lines again after settling
          const cleared = this.grid.checkLines();
          if (cleared.length > 0) this.doLineClear(cleared);
          else this.spawnPiece();
        }
      }
    }

    // Piece drop
    if (!this.sandFalling && this.current) {
      this.dropTimer += dt;
      if (this.dropTimer >= this.dropInterval) {
        this.dropTimer = 0;
        this.moveDown();
      }
    }

    this.draw();
    requestAnimationFrame(t => this.loop(t));
  }

  moveDown() {
    if (!this.current) return;
    if (!this.current.collides(this.grid, 0, 1)) {
      this.current.by++;
    } else {
      this.lockPiece();
    }
  }

  lockPiece() {
    // Dissolve piece into sand
    const color = this.current.color;
    for (const [r, c] of this.current.sandCells()) {
      if (r >= 0 && r < SAND_ROWS && c >= 0 && c < SAND_COLS) {
        // slight color variation per particle
        const v = Math.floor((Math.random() - 0.5) * 20);
        this.grid.set(r, c, [
          Math.min(255, Math.max(0, color[0] + v)),
          Math.min(255, Math.max(0, color[1] + v)),
          Math.min(255, Math.max(0, color[2] + v))
        ]);
      }
    }
    this.current = null;

    // Check overflow
    if (this.grid.isOverflowed()) { this.gameOver(); return; }

    // Let sand settle briefly, then check lines
    this.sandFalling = true;
    this.settleFrames = 0;
  }

  doLineClear(cleared) {
    const n = cleared.length;
    // Score: 1=100, 2=300, 3=500, 4=800 Ã— level
    const pts = [0, 100, 300, 500, 800];
    this.score += (pts[Math.min(n, 4)] || n * 200) * this.level;
    this.lines += n;
    this.level = Math.floor(this.lines / 10) + 1;
    this.dropInterval = Math.max(100, 800 - (this.level - 1) * 70);
    this.grid.clearRows(cleared);
    this.updateUI();
    // After clearing, let sand settle again
    this.sandFalling = true;
    this.settleFrames = 0;
  }

  hardDrop() {
    if (!this.current || this.sandFalling) return;
    while (!this.current.collides(this.grid, 0, 1)) {
      this.current.by++;
      this.score += 2;
    }
    this.lockPiece();
    this.updateUI();
  }

  moveLeft()  { if (this.current && !this.sandFalling && !this.current.collides(this.grid, -1, 0)) { this.current.bx--; } }
  moveRight() { if (this.current && !this.sandFalling && !this.current.collides(this.grid,  1, 0)) { this.current.bx++; } }

  tryRotate() {
    if (!this.current || this.sandFalling) return;
    const rotated = this.current.rotate();
    // Wall kick: try 0, -1, +1, -2, +2
    for (const kick of [0, -1, 1, -2, 2]) {
      if (!this.current.collides(this.grid, kick, 0, rotated)) {
        this.current.blocks = rotated;
        this.current.bx += kick;
        return;
      }
    }
  }

  gameOver() {
    this.running = false;
    this.over = true;
    showMsgOverlay('GAME OVER', `Score: ${this.score} | Lines: ${this.lines}`);
  }

  // â”€â”€â”€ Drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  draw() {
    const sandPx = canvas._sandPx || 2;
    ctx.fillStyle = '#0d0804';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw sand grid
    const imgData = ctx.createImageData(canvas.width, canvas.height);
    const data = imgData.data;
    for (let r = 0; r < SAND_ROWS; r++) {
      for (let c = 0; c < SAND_COLS; c++) {
        const color = this.grid.cells[r][c];
        if (!color) continue;
        for (let py = 0; py < sandPx; py++) {
          for (let px = 0; px < sandPx; px++) {
            const idx = ((r * sandPx + py) * canvas.width + (c * sandPx + px)) * 4;
            data[idx]   = color[0];
            data[idx+1] = color[1];
            data[idx+2] = color[2];
            data[idx+3] = 255;
          }
        }
      }
    }
    ctx.putImageData(imgData, 0, 0);

    // Draw current piece (ghost + solid)
    if (this.current) {
      // Ghost piece
      let ghostBy = this.current.by;
      while (!this.current.collides(this.grid, 0, ghostBy - this.current.by + 1)) ghostBy++;
      if (ghostBy !== this.current.by) {
        ctx.globalAlpha = 0.2;
        this.drawPieceAt(this.current, this.current.bx, ghostBy, sandPx);
        ctx.globalAlpha = 1;
      }
      // Solid piece
      this.drawPieceAt(this.current, this.current.bx, this.current.by, sandPx);
    }

    // Grid lines (subtle)
    ctx.strokeStyle = 'rgba(80,50,20,0.15)';
    ctx.lineWidth = 0.5;
    for (let c = 0; c <= SAND_COLS; c += SAND_SIZE) {
      ctx.beginPath();
      ctx.moveTo(c * sandPx, 0);
      ctx.lineTo(c * sandPx, canvas.height);
      ctx.stroke();
    }
  }

  drawPieceAt(piece, bx, by, sandPx) {
    const [r, g, b] = piece.color;
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    for (const [dx, dy] of piece.blocks) {
      const px = (bx + dx) * SAND_SIZE * sandPx;
      const py = (by + dy) * SAND_SIZE * sandPx;
      ctx.fillRect(px, py, SAND_SIZE * sandPx, SAND_SIZE * sandPx);
      // inner highlight
      ctx.fillStyle = `rgba(255,255,255,0.15)`;
      ctx.fillRect(px + 1, py + 1, SAND_SIZE * sandPx - 2, SAND_SIZE * sandPx - 2);
      ctx.fillStyle = `rgb(${r},${g},${b})`;
    }
  }

  drawNext() {
    nextCtx.fillStyle = '#1a0e04';
    nextCtx.fillRect(0, 0, 80, 80);
    if (!this.next) return;
    const [r, g, b] = this.next.color;
    nextCtx.fillStyle = `rgb(${r},${g},${b})`;
    const bs = 14; // block size in next preview
    const minX = Math.min(...this.next.blocks.map(b => b[0]));
    const minY = Math.min(...this.next.blocks.map(b => b[1]));
    const maxX = Math.max(...this.next.blocks.map(b => b[0]));
    const maxY = Math.max(...this.next.blocks.map(b => b[1]));
    const offX = Math.floor((80 - (maxX - minX + 1) * bs) / 2);
    const offY = Math.floor((80 - (maxY - minY + 1) * bs) / 2);
    for (const [dx, dy] of this.next.blocks) {
      nextCtx.fillRect(offX + (dx - minX) * bs, offY + (dy - minY) * bs, bs - 1, bs - 1);
    }
  }

  updateUI() {
    document.getElementById('score-val').textContent = this.score;
    document.getElementById('level-val').textContent = this.level;
    document.getElementById('lines-val').textContent = this.lines;
  }
}

// â”€â”€â”€ UI helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const overlay = document.getElementById('msg-overlay');
function showMsgOverlay(title, sub) {
  overlay.innerHTML = `<h2>${title}</h2><p>${sub}</p>`;
  overlay.style.display = 'block';
}
function hideMsgOverlay() { overlay.style.display = 'none'; }

// â”€â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let game = null;

document.getElementById('btn-start').addEventListener('click', () => {
  game = new Game();
  game.start();
});

document.addEventListener('keydown', e => {
  if (!game) return;
  if (!game.running && !game.over) return;
  if (game.over && e.code === 'Space') { game = new Game(); game.start(); return; }
  if (!game.running) return;
  switch (e.code) {
    case 'ArrowLeft':  e.preventDefault(); game.moveLeft();  break;
    case 'ArrowRight': e.preventDefault(); game.moveRight(); break;
    case 'ArrowDown':  e.preventDefault(); game.moveDown();  break;
    case 'ArrowUp':    e.preventDefault(); game.tryRotate(); break;
    case 'Space':      e.preventDefault(); game.hardDrop();  break;
    case 'KeyZ':       game.tryRotate(); break;
  }
});

// Mobile buttons
document.getElementById('btn-left').addEventListener('click',   () => game && game.moveLeft());
document.getElementById('btn-right').addEventListener('click',  () => game && game.moveRight());
document.getElementById('btn-rotate').addEventListener('click', () => game && game.tryRotate());
document.getElementById('btn-down').addEventListener('click',   () => game && game.hardDrop());

// Touch swipe on canvas
let touchStartX = 0, touchStartY = 0;
canvas.addEventListener('touchstart', e => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchend', e => {
  if (!game || !game.running) return;
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  const absDx = Math.abs(dx), absDy = Math.abs(dy);
  if (absDx < 10 && absDy < 10) { game.tryRotate(); return; }
  if (absDx > absDy) {
    if (dx < 0) game.moveLeft(); else game.moveRight();
  } else {
    if (dy > 0) game.hardDrop(); else game.tryRotate();
  }
  e.preventDefault();
}, { passive: false });

// Initial draw placeholder
canvas._sandPx = canvas._sandPx || 2;
ctx.fillStyle = '#0d0804';
ctx.fillRect(0, 0, canvas.width, canvas.height);
</script>
</body>
</html>
